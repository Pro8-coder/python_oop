"""
В программе объявлен базовый класс Function (функция) следующим образом:

class Function:
    def __init__(self):
        self._amplitude = 1.0     # амплитуда функции
        self._bias = 0.0          # смещение функции по оси Oy

    def __call__(self, x, *args, **kwargs):
        return self._amplitude * self._get_function(x) + self._bias

    def _get_function(self, x):
        raise NotImplementedError('метод _get_function должен быть
        переопределен в дочернем классе')

    def __add__(self, other):
        if type(other) not in (int, float):
            raise TypeError('смещение должно быть числом')

        obj = self.__class__(self)
        obj._bias = self._bias + other
        return obj
Здесь в инициализаторе создаются два локальных атрибута:

_amplitude - амплитуда функции;
_bias - смещение функции по оси ординат (Oy).

Далее, в методе __call__() берется значение функции в точке x через метод
_get_function(), который должен быть определен в дочерних классах, умножается
на амплитуду функции и добавляется ее смещение. Следующий метод __add__()
позволяет менять смещение функции, изменяя атрибут _bias на указанное значение
other.

Обратите внимание, в методе __add__() происходит создание нового объекта
командой:

obj = self.__class__(self)
Здесь __class__ - это ссылка на класс, к которому относится объект self.
Благодаря этому в базовом классе можно создавать объекты соответствующих
дочерних классов. В момент создания объекта ему передается параметр self как
аргумент. Так будет создаваться копия объекта, т.е. новый объект с тем же
набором и значениями локальных атрибутов.

Чтобы обеспечить этот функционал, объявите дочерний класс с именем Linear
(линейная функция y = k*x + b), объекты которого должны создаваться командами:

obj = Linear(k, b)
linear = Linear(obj)  # этот вариант используется в базовом классе в методе
__add__()
В первом случае происходит создание объекта линейной функции с параметрами k и
b. Во втором - создание объекта со значениями параметров k и b, взятыми из
объекта obj.

В каждом объекте класса Linear должны создаваться локальные атрибуты с именами
_k и _b с соответствующими значениями.
В результате будет создан универсальный базовый класс Function для работы с
произвольными функциями от одного аргумента.

Применять эти классы можно следующим образом (эти строчки в программе писать
не нужно):

f = Linear(1, 0.5)
f2 = f + 10   # изменение смещения (атрибут _bias)
y1 = f(0)     # 0.5
y2 = f2(0)    # 10.5
Пропишите в базовом классе Function еще один магический метод для изменения
масштаба (амплитуды) функции, чтобы был доступен оператор умножения:

f = Linear(1, 0.5)
f2 = f * 5    # изменение амплитуды (атрибут _amplitude)
y1 = f(0)     # 0.5
y2 = f2(0)    # 2.5
P.S. В программе следует объявить только классы. На экран выводить ничего
не нужно.
"""
from typing import Any


class Function:
    """
    Базовый класс для математических функций одного аргумента.

    Позволяет выполнять операции сложения (изменение смещения) и умножения
    (изменение амплитуды) с числовыми значениями.

    :ivar _amplitude (float): амплитуда функции (масштаб по оси Oy)
    :ivar _bias (float): смещение функции по оси Oy
    """

    def __init__(self) -> None:
        self._amplitude = 1.0
        self._bias = 0.0

    def __call__(self, x: int | float, *args, **kwargs) -> float:
        """
        Вычисляет значение функции в точке x.

        :param x: Точка, в которой вычисляется функция
        :return: Результат вычисления функции
        :raises NotImplementedError: Если метод _get_function не переопределен
        """
        return self._amplitude * self._get_function(x) + self._bias

    def _get_function(self, x: int | float) -> Any:
        """
        Абстрактный метод для вычисления базовой функции.

        Должен быть переопределен в дочерних классах.

        :param x: Точка вычисления
        :raises NotImplementedError: Всегда, так как это абстрактный метод
        """
        raise NotImplementedError('метод _get_function должен быть '
                                  'переопределен в дочернем классе')

    def __add__(self, other: int | float) -> 'Function':
        """
        Изменяет смещение функции.

        :param other: Величина смещения
        :return: Новый объект функции с измененным смещением
        :raises TypeError: Если other не является числом
        """
        if type(other) not in (int, float):
            raise TypeError('смещение должно быть числом')

        obj = self.__class__(self)
        obj._bias = self._bias + other
        return obj

    def __mul__(self, other: int | float) -> 'Function':
        """
        Изменяет амплитуду функции.

        :param other: Множитель амплитуды
        :return: Новый объект функции с измененной амплитудой
        :raises TypeError: Если other не является числом
        """
        if type(other) not in (int, float):
            raise TypeError('смещение должно быть числом')

        obj = self.__class__(self)
        obj._amplitude = self._amplitude * other
        return obj


class Linear(Function):
    """
    Класс линейной функции вида y = k*x + b.

    Наследует функциональность базового класса Function.
    Может быть создана двумя способами:
        1. Linear(k, b) - напрямую задаются параметры
        2. Linear(linear_obj) - копируются параметры из другого объекта

    :ivar _k: Коэффициент наклона
    :ivar _b: Свободный член
    """

    def __init__(self, *args) -> None:
        super().__init__()
        self._k, self._b = ((args[0], args[1]) if len(args) == 2
                              else (args[0]._k, args[0]._b))

    def _get_function(self, x: int | float) -> int | float:
        """
        Вычисляет значение линейной функции в точке x.

        :param x: Точка вычисления
        :return: Значение функции k*x + b
        """
        return self._k * x + self._b

