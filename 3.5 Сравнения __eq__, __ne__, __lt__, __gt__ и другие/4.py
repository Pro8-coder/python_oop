"""
Ваша задача написать программу поиска слова в строке. Задача усложняется тем,
что слово должно определяться в разных его формах. Например, слово:

программирование

может иметь следующие формы:

программирование, программированию, программированием, программировании,
программирования, программированиям, программированиями, программированиях

Для решения этой задачи необходимо объявить класс Morph (морфология),
объекты которого создаются командой:

mw = Morph(word1, word2, ..., wordN)
где word1, word2, ..., wordN - возможные формы слова.

В классе Morph реализовать методы:

add_word(self, word) - добавление нового слова (если его нет в списке слов
объекта класса Morph);
get_words(self) - получение кортежа форм слов.

Также с объектами класса Morph должны выполняться следующие операторы
сравнения:

mw1 == "word"  # True, если объект mv1 содержит слово "word"
(без учета регистра)
mw1 != "word"  # True, если объект mv1 не содержит слово "word"
(без учета регистра)
И аналогичная пара сравнений:

"word" == mw1
"word" != mw1
После создания класса Morph, формируется список dict_words из объектов этого
класса, для следующих слов с их словоформами:

- связь, связи, связью, связей, связям, связями, связях
- формула, формулы, формуле, формулу, формулой, формул, формулам, формулами,
формулах
- вектор, вектора, вектору, вектором, векторе, векторы, векторов, векторам,
векторами, векторах
- эффект, эффекта, эффекту, эффектом, эффекте, эффекты, эффектов, эффектам,
эффектами, эффектах
- день, дня, дню, днем, дне, дни, дням, днями, днях

Затем, прочитайте строку из входного потока командой:

text = input()
Найдите все вхождения слов из списка dict_words (используя операторы
сравнения) в строке text (без учета регистра, знаков пунктуаций и их
словоформы). Выведите на экран полученное число.

Sample Input:

Мы будем устанавливать связь завтра днем.
Sample Output:

2
"""
import re


class Morph:
    """
    Класс для представления морфологических форм слова.

    :ivar args: Возможные формы слова.
    """

    def __init__(self, *args: str) -> None:
        self.args: list[str] = list(args)

    def add_word(self, word: str) -> None:
        """
        Добавляет новую форму слова, если её ещё нет в списке.

        :param word: Новая форма слова.
        """
        if isinstance(word, str) and word not in self.args:
            self.args.append(word)

    def get_words(self) -> tuple[str, ...]:
        """
        Возвращает кортеж форм слова.

        :return: Кортеж форм слова.
        """
        return tuple(self.args)

    def __eq__(self, other: str | 'Morph') -> bool:
        """
        Сравнивает объект Morph со строкой или другим
        объектом Morph (без учета регистра).

        :param other: Строка или объект Morph для сравнения.
        :return: True, если строка содержится в формах слова.
        """
        if isinstance(other, (str, Morph)):
            return any(word.lower() == other.lower() for word in self.args)


dict_words = [
    Morph("связь", "связи", "связью", "связей", "связям", "связями", "связях"),
    Morph("формула", "формулы", "формуле", "формулу", "формулой", "формул",
          "формулам", "формулами", "формулах"),
    Morph("вектор", "вектора", "вектору", "вектором", "векторе", "векторы",
          "векторов", "векторам", "векторами", "векторах"),
    Morph("эффект", "эффекта", "эффекту", "эффектом", "эффекте", "эффекты",
          "эффектов", "эффектам", "эффектами", "эффектах"),
    Morph("день", "дня", "дню", "днем", "дне", "дни", "дням", "днями", "днях")
]

text = input()
cleaned_text = re.sub(r"[^\w\s]", "", text)

count = 0
for i in cleaned_text.split():
    for morph in dict_words:
        if i == morph:
            count += 1

print(count)
